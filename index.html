<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <title>Map Viewer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      @font-face {
        font-family: "PinyinFont";
        src: url("./fonts/PinyinFont.woff2") format("woff2");
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }
      :root {
        --bg: #fff6fb;
        --card: rgba(255, 255, 255, 0.82);
        --card-stroke: rgba(255, 105, 180, 0.22);
        --shadow: 0 14px 34px rgba(255, 105, 180, 0.18);
        --shadow-strong: 0 18px 44px rgba(255, 105, 180, 0.26);
        --text: #2a1630;
        --text-subtle: rgba(42, 22, 48, 0.72);
        --pink: #ff4da6;
        --pink-2: #ff7cc6;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(
            1400px 800px at 20% 0%,
            rgba(255, 77, 166, 0.16),
            rgba(255, 255, 255, 0) 55%
          ),
          radial-gradient(
            1200px 700px at 90% 10%,
            rgba(122, 124, 255, 0.14),
            rgba(255, 255, 255, 0) 58%
          ),
          var(--bg);
      }
      #map {
        height: 100%;
        width: 100%;
        background: linear-gradient(180deg, #ffe6f4 0%, #fff6fb 65%);
      }
      .topbar {
        position: fixed;
        left: env(safe-area-inset-left);
        right: env(safe-area-inset-right);
        top: env(safe-area-inset-top);
        padding: 10px;
        z-index: 1000;
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
        pointer-events: none;
      }
      .panel {
        pointer-events: auto;
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 9px 11px;
        border-radius: 14px;
        background: var(--card);
        border: 1px solid var(--card-stroke);
        color: var(--text);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
      }
      .panel label {
        font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial,
          "PingFang SC", "Microsoft YaHei", sans-serif;
        color: var(--text-subtle);
      }
      .bilingual {
        display: inline-flex;
        flex-direction: column;
        gap: 2px;
        align-items: center;
      }
      .hz-text {
        font: 15px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial,
          "PingFang SC", "Microsoft YaHei", sans-serif;
        font-weight: 650;
        letter-spacing: 0.2px;
      }
      .pinyin-text {
        font-family: "PinyinFont", ui-sans-serif, system-ui, -apple-system,
          Segoe UI, Roboto, Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
        font-size: 13px;
        line-height: 1.1;
        letter-spacing: 0.4px;
        font-variant-ligatures: none;
        font-feature-settings: "liga" 0, "calt" 0;
        color: rgba(255, 77, 166, 0.92);
      }
      .panel select,
      .panel button {
        font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial,
          "PingFang SC", "Microsoft YaHei", sans-serif;
        border-radius: 12px;
        border: 1px solid rgba(255, 77, 166, 0.22);
        background: rgba(255, 255, 255, 0.76);
        color: var(--text);
        padding: 8px 10px;
      }
      .panel select {
        padding-right: 26px;
      }
      .panel select:focus,
      .panel button:focus {
        outline: none;
        box-shadow: 0 0 0 4px rgba(255, 77, 166, 0.16);
      }
      .panel button .bilingual {
        align-items: center;
      }
      .panel button {
        cursor: pointer;
        white-space: nowrap;
        background: linear-gradient(
          180deg,
          rgba(255, 77, 166, 0.18),
          rgba(255, 255, 255, 0.82)
        );
        border-color: rgba(255, 77, 166, 0.26);
      }
      .panel button:active {
        transform: translateY(1px);
      }
      .hint {
        position: fixed;
        left: 50%;
        bottom: calc(env(safe-area-inset-bottom) + 14px);
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(255, 255, 255, 0.88);
        color: var(--text);
        border: 1px solid rgba(255, 77, 166, 0.22);
        padding: 9px 12px;
        border-radius: 14px;
        box-shadow: var(--shadow-strong);
        font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial,
          "PingFang SC", "Microsoft YaHei", sans-serif;
        display: none;
      }

      /* Leaflet controls: soft iOS pink glass */
      .leaflet-control-zoom a,
      .leaflet-control-layers-toggle,
      .leaflet-bar a {
        background: rgba(255, 255, 255, 0.88) !important;
        color: var(--text) !important;
        border: 1px solid rgba(255, 77, 166, 0.22) !important;
        box-shadow: var(--shadow) !important;
      }
      .leaflet-bar a:hover {
        background: rgba(255, 255, 255, 0.94) !important;
      }
      .leaflet-control-scale-line {
        background: rgba(255, 255, 255, 0.86) !important;
        color: var(--text) !important;
        border: 1px solid rgba(255, 77, 166, 0.22) !important;
        box-shadow: var(--shadow) !important;
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="panel" role="group" aria-label="Map controls">
        <label for="provider">
          <span class="bilingual">
            <span class="hz-text">图源</span>
            <span class="pinyin-text" data-pinyin="túyuán"></span>
          </span>
        </label>
        <select id="provider">
          <option value="GaoDe" data-hz="高德" data-py="gāodé"></option>
          <option value="TianDiTu" data-hz="天地图" data-py="tiāndìtú"></option>
          <option
            value="Google"
            data-hz="谷歌"
            data-py="gǔgē"
          ></option>
          <option value="OSM" data-hz="OSM" data-py="ōu ès ēm"></option>
        </select>
        <label for="mode">
          <span class="bilingual">
            <span class="hz-text">模式</span>
            <span class="pinyin-text" data-pinyin="móshì"></span>
          </span>
        </label>
        <select id="mode">
          <option value="sat" data-hz="卫星" data-py="wèixīng"></option>
          <option value="road" data-hz="道路" data-py="dàolù"></option>
        </select>
        <button id="reset" type="button"></button>
        <button id="locate" type="button"></button>
        <button id="share" type="button"></button>
      </div>
      <div class="panel" aria-label="Status">
        <span id="status" style="font: 13px/1.2 system-ui">就绪</span>
      </div>
    </div>
    <div id="map"></div>
    <div id="hint" class="hint"></div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script src="./src/leaflet.ChineseTmsProviders.js"></script>
    <script src="./app-config.js"></script>
    <script>
      (function () {
        const statusEl = document.getElementById("status");
        const hintEl = document.getElementById("hint");
        const providerEl = document.getElementById("provider");
        const modeEl = document.getElementById("mode");
        const resetBtn = document.getElementById("reset");
        const locateBtn = document.getElementById("locate");
        const shareBtn = document.getElementById("share");

        const PRESETS = {
          GaoDe: { sat: "Satellite.Map", labels: "Satellite.Annotion" },
          TianDiTu: { sat: "Satellite.Map", labels: "Satellite.Annotion" },
          Google: { sat: "Satellite.Map", labels: "Satellite.Annotion" },
          OSM: { sat: "Normal.Map", labels: null }
        };

        function normalizePinyin(text) {
          if (!text) return "";
          // 1) NFD to decompose ā/á/ǎ/à into a + combining mark.
          // 2) Replace 'a' with IPA open-a 'ɑ' so it never falls back to odd glyphs.
          return text.normalize("NFD").replace(/a/g, "ɑ");
        }

        function setBilingualButton(btn, hanzi, pinyin) {
          btn.innerHTML =
            `<span class=\"bilingual\">` +
            `<span class=\"hz-text\">${hanzi}</span>` +
            `<span class=\"pinyin-text\">${normalizePinyin(pinyin)}</span>` +
            `</span>`;
        }

        // Fill all bilingual labels/options/buttons.
        document.querySelectorAll("[data-pinyin]").forEach((el) => {
          el.textContent = normalizePinyin(el.getAttribute("data-pinyin"));
        });
        document.querySelectorAll("select option[data-hz][data-py]").forEach((opt) => {
          opt.textContent = `${opt.getAttribute("data-hz")} ${normalizePinyin(
            opt.getAttribute("data-py")
          )}`;
        });
        setBilingualButton(document.getElementById("reset"), "复位", "fùwèi");
        setBilingualButton(document.getElementById("locate"), "定位", "dìngwèi");
        setBilingualButton(
          document.getElementById("share"),
          "复制链接",
          "fùzhì liànjiē"
        );

        function setStatus(text) {
          statusEl.textContent = text;
        }

        let hintTimer = null;
        function showHint(text, ms = 1400) {
          hintEl.textContent = text;
          hintEl.style.display = "block";
          if (hintTimer) window.clearTimeout(hintTimer);
          hintTimer = window.setTimeout(() => {
            hintEl.style.display = "none";
          }, ms);
        }

        function getConfig() {
          const cfg = (window.APP_CONFIG && window.APP_CONFIG.default) || {};
          return {
            title: (window.APP_CONFIG && window.APP_CONFIG.title) || "Map Viewer",
            center: cfg.center || { lat: 31.2304, lng: 121.4737 },
            zoom: Number.isFinite(cfg.zoom) ? cfg.zoom : 12,
            provider: cfg.provider || "GaoDe",
            mode: cfg.mode === "road" ? "road" : "sat",
            autoLocate:
              cfg.autoLocate === "always" || cfg.autoLocate === "once"
                ? cfg.autoLocate
                : "off",
            autoLocateZoom:
              Number.isFinite(cfg.autoLocateZoom) && cfg.autoLocateZoom >= 0
                ? cfg.autoLocateZoom
                : 14,
            report: {
              enabled: !!(cfg.report && cfg.report.enabled),
              endpoint: (cfg.report && cfg.report.endpoint) || "",
              token: (cfg.report && cfg.report.token) || "",
              sendOnLocate:
                cfg.report && typeof cfg.report.sendOnLocate === "boolean"
                  ? cfg.report.sendOnLocate
                  : true,
              intervalMinutes:
                cfg.report &&
                Number.isFinite(cfg.report.intervalMinutes) &&
                cfg.report.intervalMinutes > 0
                  ? cfg.report.intervalMinutes
                  : 0
            },
            sat: cfg.sat || "Satellite.Map",
            labels: cfg.labels || "Satellite.Annotion",
            tianDiTuKey: cfg.tianDiTuKey || ""
          };
        }

        function parseQuery() {
          const q = new URLSearchParams(location.search);
          const lat = q.get("lat");
          const lng = q.get("lng");
          const z = q.get("z");
          return {
            lat: lat != null ? Number(lat) : null,
            lng: lng != null ? Number(lng) : null,
            z: z != null ? Number(z) : null,
            provider: q.get("provider"),
            mode: q.get("mode"),
            autoLocate: q.get("autoLocate"),
            sat: q.get("sat"),
            labels: q.get("labels"),
            tianDiTuKey: q.get("tianDiTuKey")
          };
        }

        const config = getConfig();
        document.title = config.title;

        const q = parseQuery();
        const initialCenter = {
          lat:
            Number.isFinite(q.lat) && Math.abs(q.lat) <= 90
              ? q.lat
              : config.center.lat,
          lng:
            Number.isFinite(q.lng) && Math.abs(q.lng) <= 180
              ? q.lng
              : config.center.lng
        };
        const initialZoom =
          Number.isFinite(q.z) && q.z >= 0 && q.z <= 22 ? q.z : config.zoom;
        const initialProvider = q.provider || config.provider;
        const initialMode = q.mode === "road" ? "road" : config.mode;
        const initialAutoLocate =
          q.autoLocate === "1" || q.autoLocate === "true"
            ? "always"
            : q.autoLocate === "0" || q.autoLocate === "false"
              ? "off"
              : config.autoLocate;
        const preset = PRESETS[initialProvider] || PRESETS.GaoDe;
        const initialSat = q.sat || config.sat || preset.sat;
        const initialLabels =
          q.labels != null ? q.labels : config.labels || preset.labels;
        const tianDiTuKey = q.tianDiTuKey || config.tianDiTuKey || "";

        providerEl.value = initialProvider;
        modeEl.value = initialMode;

        const map = L.map("map", {
          center: [initialCenter.lat, initialCenter.lng],
          zoom: initialZoom,
          zoomControl: true
        });

        map.attributionControl.setPrefix(false);
        L.control
          .scale({ metric: true, imperial: false, maxWidth: 120, updateWhenIdle: true })
          .addTo(map);

        let currentBase = null;
        let currentLabels = null;
        let selectedSat = initialSat;
        let selectedLabels = initialLabels;
        let selectedMode = initialMode;

        function getOrCreateDeviceId() {
          try {
            const key = "mapViewer:deviceId";
            const existing = localStorage.getItem(key);
            if (existing) return existing;
            const id =
              (crypto && crypto.randomUUID && crypto.randomUUID()) ||
              `dev_${Math.random().toString(16).slice(2)}_${Date.now()}`;
            localStorage.setItem(key, id);
            return id;
          } catch (_) {
            return `dev_${Math.random().toString(16).slice(2)}_${Date.now()}`;
          }
        }

        const deviceId = getOrCreateDeviceId();
        let reportedThisSession = false;

        async function reportLocation(payload) {
          if (!config.report.enabled) return;
          if (!config.report.endpoint) return;
          if (reportedThisSession) return;
          reportedThisSession = true;

          const body = JSON.stringify(payload);
          const headers = { "content-type": "application/json" };
          if (config.report.token) headers.authorization = `Bearer ${config.report.token}`;

          // Prefer sendBeacon if available (more reliable on unload), else fetch keepalive.
          try {
            if (navigator.sendBeacon) {
              const blob = new Blob([body], { type: "application/json" });
              const ok = navigator.sendBeacon(config.report.endpoint, blob);
              if (ok) return;
            }
          } catch (_) {}

          try {
            await fetch(config.report.endpoint, {
              method: "POST",
              headers,
              body,
              keepalive: true,
              mode: "cors"
            });
          } catch (e) {
            // Best-effort; ignore network errors.
            console.warn("reportLocation failed", e);
          }
        }

        function makeLayer(type) {
          const options = {};
          if (type.startsWith("TianDiTu.") && tianDiTuKey) options.key = tianDiTuKey;
          return L.tileLayer.chinaProvider(type, options);
        }

        function hasLayer(provider, group, variant) {
          const prov = L.TileLayer.ChinaProvider.providers[provider];
          if (!prov) return false;
          const bucket = prov[group];
          if (!bucket) return false;
          return Object.prototype.hasOwnProperty.call(bucket, variant);
        }

        function chooseSafeLayers(provider) {
          const p = PRESETS[provider] || PRESETS.GaoDe;
          // Mode decides the target layers.
          let sat = null;
          let labels = null;

          if (selectedMode === "road") {
            // Prefer "Normal.Map" and, for TianDiTu, the separate annotation layer.
            if (provider === "TianDiTu") {
              sat = "Normal.Map";
              labels = "Normal.Annotion";
            } else {
              sat = "Normal.Map";
              labels = null;
            }
          } else {
            sat = selectedSat || p.sat;
            labels = selectedLabels != null ? selectedLabels : p.labels;
          }

          // Validate "group.variant" exists; fallback to preset.
          const satParts = String(sat).split(".");
          if (satParts.length !== 2 || !hasLayer(provider, satParts[0], satParts[1])) {
            sat = selectedMode === "road" ? "Normal.Map" : p.sat;
          }
          if (labels) {
            const lblParts = String(labels).split(".");
            if (
              lblParts.length !== 2 ||
              !hasLayer(provider, lblParts[0], lblParts[1])
            ) {
              labels = selectedMode === "road" ? null : p.labels;
            }
          }
          return { sat, labels };
        }

        function setLayers(provider, sat, labels) {
          setStatus("切换图层…");
          const baseType = `${provider}.${sat}`;
          const labelsType = labels ? `${provider}.${labels}` : null;

          try {
            if (currentBase) map.removeLayer(currentBase);
            if (currentLabels) map.removeLayer(currentLabels);
            currentLabels = null;

            currentBase = makeLayer(baseType);
            currentBase.addTo(map);

            // Some providers have no labels for some layer groups.
            if (labelsType) {
              currentLabels = makeLayer(labelsType);
              currentLabels.addTo(map);
            }
            setStatus(`${provider} · ${sat}${labels ? " + " + labels : ""}`);
          } catch (e) {
            console.error(e);
            setStatus("图层切换失败");
            showHint("图层切换失败：请换一个图源/图层组合");
          }
        }

        // Default layers
        {
          const chosen = chooseSafeLayers(initialProvider);
          selectedSat = chosen.sat;
          selectedLabels = chosen.labels;
          setLayers(initialProvider, selectedSat, selectedLabels);
        }

        providerEl.addEventListener("change", () => {
          const provider = providerEl.value;
          const chosen = chooseSafeLayers(provider);
          selectedSat = chosen.sat;
          selectedLabels = chosen.labels;
          setLayers(provider, selectedSat, selectedLabels);
        });

        modeEl.addEventListener("change", () => {
          selectedMode = modeEl.value === "road" ? "road" : "sat";
          const provider = providerEl.value;
          const chosen = chooseSafeLayers(provider);
          selectedSat = chosen.sat;
          selectedLabels = chosen.labels;
          setLayers(provider, selectedSat, selectedLabels);
        });

        resetBtn.addEventListener("click", () => {
          providerEl.value = config.provider || "GaoDe";
          modeEl.value = config.mode === "road" ? "road" : "sat";
          selectedMode = modeEl.value;

          const provider = providerEl.value;
          const chosen = chooseSafeLayers(provider);
          selectedSat = chosen.sat;
          selectedLabels = chosen.labels;
          setLayers(provider, selectedSat, selectedLabels);

          const center = config.center || { lat: 31.2304, lng: 121.4737 };
          const zoom =
            Number.isFinite(config.zoom) && config.zoom >= 0 && config.zoom <= 22
              ? config.zoom
              : 12;
          map.setView([center.lat, center.lng], zoom);
          showHint("已回到默认位置");
        });

        function locateNow(reason) {
          if (!navigator.geolocation) {
            showHint("此浏览器不支持定位");
            return;
          }
          setStatus("定位中…");
          navigator.geolocation.getCurrentPosition(
            async (pos) => {
              const { latitude, longitude } = pos.coords;
              const targetZoom = Math.max(map.getZoom(), config.autoLocateZoom || 14);
              map.setView([latitude, longitude], targetZoom);
              setStatus("已定位");
              showHint(reason === "auto" ? "已定位到当前位置" : "已定位到当前位置");

              if (config.report.enabled && config.report.sendOnLocate) {
                await reportLocation({
                  ts: new Date().toISOString(),
                  reason,
                  deviceId,
                  coords: {
                    lat: latitude,
                    lng: longitude,
                    accuracy: pos.coords.accuracy,
                    altitude: pos.coords.altitude,
                    heading: pos.coords.heading,
                    speed: pos.coords.speed
                  },
                  map: {
                    zoom: map.getZoom(),
                    provider: providerEl.value,
                    mode: selectedMode
                  }
                });
              }
            },
            (err) => {
              console.warn(err);
              setStatus("定位失败");
              showHint("定位失败：请允许定位权限");
            },
            { enableHighAccuracy: true, timeout: 8000, maximumAge: 30000 }
          );
        }

        locateBtn.addEventListener("click", () => locateNow("manual"));

        // Attempt auto-locate (iOS may still require a user gesture; if blocked, user can tap “定位”).
        try {
          const key = "mapViewer:autoLocateDone";
          const already =
            initialAutoLocate === "once" && localStorage.getItem(key) === "1";
          if (!already && initialAutoLocate !== "off") {
            setTimeout(() => locateNow("auto"), 0);
            if (initialAutoLocate === "once") localStorage.setItem(key, "1");
          }
        } catch (_) {
          // ignore localStorage errors
        }

        // Periodic reporting (optional; best-effort; iOS may throttle timers in background).
        if (config.report.enabled && config.report.intervalMinutes > 0) {
          let last = 0;
          const intervalMs = config.report.intervalMinutes * 60 * 1000;
          setInterval(() => {
            const now = Date.now();
            if (document.visibilityState !== "visible") return;
            if (now - last < intervalMs - 1000) return;
            last = now;
            locateNow("hourly");
          }, 15 * 1000);
        }

        function shareUrl() {
          const c = map.getCenter();
          const z = map.getZoom();
          const provider = providerEl.value;
          const params = new URLSearchParams(location.search);
          params.set("lat", c.lat.toFixed(6));
          params.set("lng", c.lng.toFixed(6));
          params.set("z", String(z));
          params.set("provider", provider);
          params.set("mode", selectedMode);
          params.set("sat", selectedSat);
          if (selectedLabels) params.set("labels", selectedLabels);
          else params.delete("labels");
          if (provider === "TianDiTu" && tianDiTuKey) params.set("tianDiTuKey", tianDiTuKey);
          const origin = location.origin === "null" ? "" : location.origin;
          const url = `${origin}${location.pathname}?${params.toString()}`;
          return url;
        }

        shareBtn.addEventListener("click", async () => {
          const url = shareUrl();
          try {
            await navigator.clipboard.writeText(url);
            showHint("链接已复制");
          } catch (e) {
            // Fallback
            const ta = document.createElement("textarea");
            ta.value = url;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            showHint("链接已复制");
          }
        });
      })();
    </script>
  </body>
</html>
